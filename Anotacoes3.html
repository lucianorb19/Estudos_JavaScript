<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="estilo/style.css">
    <title>...</title>
</head>
<body>
    <h1>Ler argumentos do terminal</h1>
    <p>Quando for necessário usar argumentos de entrada vindos do terminal, usar a função process.argv. Julgando que é escrito no terminal <em>node index.js teste</em>, a saída process.argv[2] será 'teste'</p>
    <ul>
        <li>process.arvg[0] - caminho para o binário do nodeJS;</li>
        <li>process.arvg[1] - caminho do arquivo js sendo executado, nesse caso 'index.js'</li>
    </ul>
    <pre><code>
    const caminhoArquivo = process.argv[2];//PEGA O QUE FOR DIGITADO NO TERMINAL APÓS 'node indes.js'
    console.log(caminhoArquivo);
    </code></pre>

    <h2>Biblioteca commander - argumentos no terminal</h2>
    <p>Com o uso da função process.argv, o uso de argumentos no terminal fica limitado a ordem em que são escritos. Por exemplo, um programa, pela execução de um arquivo cls.js, faz a leitura de um arquivo de texto e gera outro arquivo de texto com as palavras repeditas de cada parágrado. Interpretando a situação, observamos que serão necessários 2 argumentos:</p>
    <ul>
        <li>O caminho do arquivo a ser lido;</li>
        <li>O caminho onde salvar o arquivo com o resultado.</li>
    </ul>

    <p>Fazendo isso pelo uso da função process.argv, teríamos:</p>
    <pre><code>
    node cli.js ./arquivos/arquivoOrigem.txt ./resultados/resultado.txt
    </code></pre>

    <p>Mas e se não quisermos depender dessa ordem de argumentos? o que fazer? <br>
       Nesse caso poderíamos usar a famosa biblioteca <u>commander, ela permite que possamos definir qual argumento da linha de comando representará qual variável no programa</u>.</p>

    <h3>Instalação</h3>
    <pre><code>
    npm install commander
    </code></pre>

    <h3>Aplicação no código</h3>
    <p>Considerando um arquivo JS que faz o uso de dois argumentos: uma string caminho do arquivo de origem, e uma string caminho do arquivo de destino, podemos ter o seguinte:</p>
    <pre><code>
    //VERSÃO COM USO DA BIBLIOTECA COMMANDER
    /*
    //FUNÇÃO QUE FAZ USO DAS VARIÁVEIS texto E destino GERADAS COM USO
    //DA BIBLIOTECA Commander
    function processaArquivo(texto, destino){
    fs.readFile(texto, 'utf-8', (erro, texto) => {
    try {
        if (erro) throw erro
        const resultado = contaPalavras(texto);
        criaESalvaArquivo(resultado, destino);
    } catch(erro) {
        trataErros(erro);
    }
    });
    }

    //OBJETO COMMAND
    const program = new Command();
    program
    .version('0.0.1')
    .option('-t, --texto <string>', 'caminho do texto a ser processado')
    .option('-d  --destino <string>', 'caminho da pasta a salvar o arquivo de resultados')
    .action((options)=> {
    const {texto, destino} = options; //DESESTRUTURAÇÃO DE ARRAY

    if(!texto || !destino){
        console.error("Erro: favor inserir caminho de origem e destino!")
        program.help();
        return;
    }

    //USO BIBLIOTECA PATH PARA MONTRAR CAMINHO DOS ARQUIVOS
    caminhoTexto = path.resolve(texto);
    caminhoDestino = path.resolve(destino);
    
    //APLICAÇÃO DA FUNÇÃO processaArquivo
    try{
        processaArquivo(caminhoTexto, caminhoDestino);
        console.log("Texto processado com sucesso!");
    }catch(erro){
        console.log("Erro no processamento", erro)
    }
    })

    program.parse();
    */
    </code></pre>

    <p>E na linha de comando, <u>ao invés de depender da orgem dos argumentos, podemos definir, qual será o texto e qual será o destino usando as <strong>flags</strong> -t e -d</u></p>
    <pre><code>
    node cli.js -t ./arquivos/arquivoOrigem.txt -d ./resultados/resultado.txt
    </code></pre>


    <h1>Operações com arquivos</h1>
    <h2>Leitura</h2>
    <p>Pode ser feita pela função <u>readFile</u>.</p>
    <pre><code>
    const fs = require('fs');//USO DE FILESYSTEM

    const caminhoArquivo = process.argv[2];//PEGA O QUE FOR DIGITADO NO TERMINAL APÓS 'node indes.js'
    console.log(caminhoArquivo);

    fs.readFile(caminhoArquivo, 'utf-8', (erro, texto)=>{
        if(erro){
            console.error("Erro:",erro);
            return;
        }
        console.log(texto);
    });
    </code></pre>

    <p>E o seguinte comando no terminal: <strong><em>node index.js ../arquivos/texto-web</em></strong></p>

    <h2>Escrita</h2>
    <p>Com uso da função <u>fs.promisses.writeFile(caminho, conteudo)</u>, sendo o primeiro parâmetro o caminho onde o arquivo será salvo, incluindo sua extensão, e o segundo uma string com seu conteúdo.</p>
    <pre><code>
    await fs.promises.writeFile(caminho, conteudo);
    </code></pre>

    <h1>Importação e Exportação de Módulos</h1>
    <p>Modularizar funcionalidades é algo comum em projetos nodeJS. Essa modularização pode ser feita da seguinte forma:</p>

    <ul>
        <li><strong>Exportação</strong> com <u>module.exports = nomeFuncao</u> no arquivo origial e <strong>importação</strong> <u>const nomeVariavel = require('caminhoArquivoOriginal')</u> no arquivo de destino.</li>
    </ul>

    <p>Outra maneira seria:</p>
    <ul>
        <li>Exportação com a palavra <u>export default</u> na única função que se deseja exportar, e no arquivo onde vai ser recebido o módulo usar <u>import nomeFuncao from 'caminhoArquivo'</u></li>
    </ul>
    
    <p>Outra maneira seria:</p>
    <ul>
        <li>Configurar o arquivo package.json da raiz do arquivo;
            <ul>
                 <li>Abrir o terminal na raiz do projeto e utilizar o comando <u>npm ini -y</u> para criar o package.json</li>
                <li>Acessar o arquivo e inserir em qualquer posião, o campo <u>"type":"module",</u></li>
            </ul>
           
        </li>
        <li>Exportação com a palavra <u>export</u> antes de cada função que se deseja exportar, e no arquivo onde vai ser recebido o módulo usar <u>import{nomeFuncao} from 'caminhoArquivo'</u></li>
    </ul>

    <p>Outra maneira seria</p>
    <ul>
        <li>Configurar o arquivo package.json da raiz do arquivo;
            <ul>
                 <li>Abrir o terminal na raiz do projeto e utilizar o comando <u>npm ini -y</u> para criar o package.json</li>
                <li>Acessar o arquivo e inserir em qualquer posião, o campo <u>"type":"module",</u></li>
            </ul>
           
        </li>
        <li>Exportação com a palavra <u>export { nomeFuncao1, nomeFuncao2 }</u> no final do arquivo, e onde vai ser recebido o módulo usar <u>import{nomeFuncao} from 'caminhoArquivo'</u></li>
    </ul>

    <h1>Operações Assíncronas - async e await, then e promessas</h1>

    <p>Operações assíncronas são aquelas que não exigem que o código seja  pausado até que sua tarefa seja executada, continuando com sua execução (em partes) até que sua resposta seja gerada e utilizada no código principal. Exemplos típicos de operações assíncronas são conexão com base de dados e operações com arquivos.</p>

    <p>Aqui um exemplo de uma operação assíncrona realizada  para escrita de arquivo no disco</p>
    <pre><code>
    async function criaESalvaArquivo(listaPalavras, endereco){
        const arquivoNovo = `${endereco}/resultado.txt`;
        const textoPalavras = JSON.stringify(listaPalavras);
        try{
        await fs.promises.writeFile(arquivoNovo, textoPalavras);
            console.log("Arquivo criado!");
        }catch(erro){
            throw erro;
        }
    }
    </code></pre>

    <p><u>Promessa</u> é um tipo de objeto JS criado para lidar com operações assíncronas, ele representa o resultado dessas operações. Seus estados são:</p>
    <ul>
        <li>Pending - pendente(em processamento);</li>
        <li>Settled - resolvida (já processada)</li>
        <li>Fulfilled - cumprida;</li>
        <li>Rejected - rejeitada (erros).</li>
    </ul>

    <p>O <u>then</u> é um método utilizada para uma construção alterativa de uma função assíncrona, que lida com o resultado dessa função. Nele é escrito o que se espera fazer com o resultado de uma função assíncrona. Abaixo, a mesma construção da função acima, mas usando then:</p>
    <pre><code>
    function criaESalvaArquivo(listaPalavras, endereco){
        const arquivoNovo = `${endereco}/resultado.txt`;
        const textoPalavras = JSON.stringify(listaPalavras);
        fs.promises.writeFile(arquivoNovo, textoPalavras)
        .then(()=>{//SEM PARÂMETRO PQ writeFile NÃO GERA RETORNO
            console.log("Arquivo criado!");
        })
        .catch((erro)=>{
            throw erro;
        })
        .finally(()=>{//É EXECUTADO DE QUALQUER FORMA
            console.log("Operação finalizada!")
        })
    }
    </code></pre>

    

    
</body>
</html>