<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="estilo/style.css">

    <title>Objetos</title>
</head>
<body>
    <h1>Objetos</h1>
    <p>Estruturas composta por propriedades (chaves e valores) e métodos.</p>
    <ul>
        <li>Delimitada por {}</li>
        <li>Cada propriedade é uma chave associada a um valor</li>
    </ul>

    <pre><code>
    const estudante = {
    nome: "Luciano",
    idade: 28,
    cpf: "12267943829",
    sexo: "M"
    };
    </code></pre>

    <p>Criação de um objeto vazio</p>
    <pre><code>
    const estudante2 = {};
    </code></pre>

    <h2>Acessando propriedades de um objeto</h2>
    <p>Utiliza-se a notação de ponto</p>
    <pre><code>
    console.log(estudante.nome);//Luciano
    </code></pre>

    <h3>Acesso a propriedades pela chave</h3>
    <p>Para situações nas quais é necessário acessar um campo específico de um objeto, a referência a esse campo é feito pela utilização da notação de conchetes [], com o nome da chave dentro.</p>

    <p>Exemplo: acessar o campo 'nome' de um objeto estudante</p>
    <pre><code>
    console.log(estudante["nome"]); //Luciano
    </code></pre>

    <p>Importante destacar que, <strong>ao tentar acessar uma propriedade que não existe, o resultado é <em>undefined</em> ao invés de erro</strong>.</p>
    <pre><code>
        console.log(estudante.cidade); //undefined
    </code></pre>

    <h3>Verificar se um objeto tem um propriedade</h3>
    <p>Para verificar se um dado objeto tem um propriedade específica (desconsiderando as herdadas), usa-se a função <strong>hasOwnProperty()</strong></p>
    <pre><code>
    const estudante = {
    nome: "Luciano",
    idade: 28,
    sexo: "Masculino"
    };

    console.log(estudante.hasOwnProperty("nome"));//TRUE
    console.log(estudante.hasOwnProperty("endereco"));//FALSE
    </code></pre>

    <h3>Propriedades enumeráveis ou não</h3>
    <p>Propriedades enumeráveis são aquelas que são consideradas durante operações de iteração, como for … in e métodos como Object.keys(). Por padrão, todas as propriedades criadas diretamente em um objeto são enumeráveis, o que significa que elas são visíveis durante a iteração.</p>

    <p>Propriedades <strong>não enumeráveis</strong> são geralmente associadas a métodos internos de objetos ou configurações específicas que não precisam ser expostas durante iterações comuns.</p>

    <p>Para manipular a enumerabilidade de uma propriedade, usa-se o método <strong>Object.defineProperty()</strong>.</p>
    <pre><code>
    const pessoa = {
    nome: "Luciano Rodrigues Batista"
    };

    Object.defineProperty(pessoa, 'idade', {
    value: 28,
    enumerable: false
    });

    console.log(Object.keys(pessoa)); // Saída: ['nome']
    </code></pre>

    <p>Importante destacar que, ser não enumerável só oculta a propriedade para casos de iteração. Isso significa que o acesso direto à propriedade ainda pode ser feito.</p>

    <pre><code>
    console.log(pessoa.idade); //SAÍDA 28
    </code></pre>

    <h2>Mudando dados do objeto / Criando novos campos</h2>
    <p>Para mudar o valor de uma propriedade</p>
    <pre><code>
    estudante.nome = "Ana";
    </code></pre>

    <p>Para criar uma nova propriedade, da mesma forma</p>
    <pre><code>
    estudante.nascimento = "19/03/2007";
    </code></pre>


    <h2>Deleção de propriedades</h2>
    <p>Usando <em>delete</em>.</p>

    <p>Com notação de ponto</p>
    <pre><code>
    delete estudante.nome;
    </code></pre>

    <p>Com notação de colchetes</p>
    <pre><code>
    delete estudante["idade"];
    </code></pre>

    <p>Destacando que delete tem sempre retorno true ou false, caso consiga ou não efetuar a deleção, porém <strong>o retorno é true mesmo ao tentar deletar uma propriedade inexistente</strong>.</p>

    <h2>Cópia de objeto</h2>
    
    <h3>Cópia com Object.create()</h3>
    <p>Considerando que, assim como em arrays, não podemos simplesmente atribuir um objeto existente para um novo (dado que isso somente criaria dois objetos diferentes apontando para a mesma posição de memória), como copiar objetos? <strong>Utilizando Object.create()</strong></p>

    <pre><code>
    const objPersonagem = {
    nome: "Gandalf",
    classe: "mago",
    nivel: "20"
    }
    
    const objPersonagem2 = Object.create(objPersonagem)
    objPersonagem2.nome = "Saruman"
    
    console.log(objPersonagem.nome) //Gandalf
    console.log(objPersonagem2.nome) //Saruman
    </code></pre>

    <h3>Cópia com JSON.parse e JSON.stringify</h3>
    <p>A cópia de um objeto JS também pode ser feita usando as funções JSON.stringify, que transformam o objeto em string, e JSON.parse, que tornam a string novamente em objeto.</p>
    <pre><code>
    const objetoOriginal = { chave: 'valor' };
    const copiaProfunda = JSON.parse(JSON.stringify(objetoOriginal));

    copiaProfunda.chave = 'novoValor';
    console.log(objetoOriginal.chave); // Saída: valor
    </code></pre>


    <h2>Atribuição entre Objetos</h2>
    <p>Pode ser feita, como no exemplo acima, por cópia através do método Object.create, mas também pela atribuição direta ou uso do <em>spread operator</em>.</p>

    <h3>Atribuição direta</h3>
    <pre><code>
    const fichaGuerreiro = {
    nome: "Aragorn",
    classe: "guerreiro"
    }
    
    const equipoGuerreiro = {
    espada: "Andúril",
    capa: "capa élfica +2"
    }

    const guerreiro = { fichaGuerreiro, equipoGuerreiro }
    console.log(guerreiro)

    //SAÍDA
    {
    fichaGuerreiro: { nome: 'Aragorn', classe: 'guerreiro' },
    equipoGuerreiro: { espada: 'Andúril', capa: 'capa élfica +2' }
    }
    </code></pre>

    <p>A atribuição direta funciona, mas ela cria dentro do objeto atribuído outros objetos. Se a intenção for copiar apenas os campos, nesse caso usa-se o <em>spread operator</em>.</p>

    <h3>Atribuição com Spread Operator</h3>
    <pre><code>
    const fichaGuerreiro = {
    nome: "Aragorn",
    classe: "guerreiro"
    }
    
    const equipoGuerreiro = {
    espada: "Andúril",
    capa: "capa élfica +2"
    }

    const guerreiro = { ...fichaGuerreiro, ...equipoGuerreiro }
    console.log(guerreiro)

    //SAÍDA
    {
    nome: 'Aragorn',
    classe: 'guerreiro',
    espada: 'Andúril',
    capa: 'capa élfica +2'
    }
    </code></pre>

    <p>Se atentar para o fato de, <strong>ao usar o spread operator, ele sobrescreve propriedades de mesmo nome que estão sendo copiadas.</strong></p>


    <h2>Percorrer um Objeto</h2>
    <h3>Com laço for..in</h3>
    <p>o laço <strong>for...in</strong> nos permite percorrer os campos de um objeto, lendo suas chaves e valores, <strong>exceto para campos complexos como objetos e funções</strong>.</p>
    <pre><code>
    const pessoa = {
        //PROPRIEDADES
        nome: "Luciano Rodrigues Batista",
        idade: 28,
        solteiro: true,
        hobbies: ["filmes", "academia", "álcool"],
        endereco: {
            rua: "Rua das Mercês",
            cidade: "Diamantina",
            estado: "MG - Minas Gerais"    
        },
        
        //MÉTODOS
        seApresentar: function(){
            console.log(`Olá, meu nome é ${this.nome}, tenho ${this.idade} e moro na ${this.endereco.rua} em ${this.endereco.cidade}!`);
        }
     };

        for(let chave in pessoa){
            console.log(`${chave} - ${pessoa[chave]}`);
        }

    //SAÍDA
    nome - Luciano Rodrigues Batista
    idade - 28
    solteiro - true
    hobbies - filmes,academia,álcool
    endereco - [object Object]
    seApresentar - function(){
        console.log(`Olá, meu nome é ${this.nome}, tenho ${this.idade} e moro na ${this.endereco.rua} em ${this.endereco.cidade}!`);
    }
    </code></pre>

    <p>O que seria útil nesse caso, seria um laço for com verificação para mostrar apenas os campos apresentáveis do objeto, ou seja, somente aqueles que não são do tipo objeto e função.</p>
    <pre><code>
    for(let chave in pessoa){
        const tipo = typeof pessoa[chave];
        if(tipo !== 'object' && tipo !== 'function'){
            console.log(`${chave} - ${pessoa[chave]}`)
        }
    }
    </code></pre>

    <h3>Com funções Object - keys, values, entries</h3>
    <h4>Object.keys e Object.values</h4>
    <p>são usados para extrair informações específicas de um objeto. Esses métodos fornecem, respectivamente, as chaves e os valores presentes em um objeto. São úteis para iterar ou fazer operações específicas em conjuntos de dados de um objeto.</p>
    <pre><code>
    const meuObjeto = { a: 1, b: 2, c: 3 };
    const chaves = Object.keys(meuObjeto);
    const valores = Object.values(meuObjeto);

    console.log(chaves); // Saída: ['a', 'b', 'c']
    console.log(valores); // Saída: [1, 2, 3]
    </code></pre>

    <h4>Object.entries</h4>
    <p>este método retorna um array de arrays que representam pares chave-valor. É útil em situações que demandam iterações mais complexas ou manipulação mais minuciosa dos dados.</p>
    <pre><code>
    const meuObjeto = { a: 1, b: 2, c: 3 };
    const entradas = Object.entries(meuObjeto);

    console.log(entradas);
    // Saída: [['a', 1], ['b', 2], ['c', 3]]
    </code></pre>

    <h4>Object.assing</h4>
    <p>usado para fusão e cópia de objetos. Este método permite combinar propriedades de diferentes objetos em um único objeto.</p>
    <pre><code>
    const objetoOriginal = { a: 1, b: 2 };
    const objetoParaCopiar = { b: 3, c: 4 };

    const objetoFusionado = Object.assign({}, objetoOriginal, objetoParaCopiar);

    console.log(objetoFusionado);
    // Saída: { a: 1, b: 3, c: 4 }
    </code></pre>



    <h2>Métodos</h2>
    <p>São funções próprias do objeto.</p>

    <pre><code>
    const estudante = {
        //PROPRIEDADES
        nome: "Luciano R B",
        idade: 28,
        telefone: "33991465987",
        mediaDeNotas: 7.8,
        
        //MÉTODOS
        estaAprovado: function(mediaBase){
            return this.mediaDeNotas >= 7 ? true : false;
        }
    }

    console.log(estudante.estaAprovado(7));//true
    </code></pre>

    <p>O <strong>this</strong> é uma referência ao próprio objeto. <br>
       <strong>Não usar this em arrow functions</strong>, o JS tem problemas de contexto nesta questão específica.</p>

    <h2>Operações com JSON</h2>
    
    <h3>Json para Objeto</h3>
    <p>A leitura de um arquivo .json para uma variável pode ser feita pela função <u>require</u>, nativa do Node.js, que aceita como parâmetro o caminho do arquivo e o converte para um objeto. Considerando um arquivo estudante.json na mesma pasta deste arquivo atual, teríamos:</p>
    <pre><code>
    const estudante = require('./estudante.json');
    </code></pre>

    <h3>Objeto para String</h3>
    <p>Conversão de objetos para strings é vantajosa para que as informações, em formato string, sejam enviadas entre o back-end e front-end.Isso pode ser feito pela função <u>JSON.stringfy()</u>.</p>
    <pre><code>
    const stringEstudante = JSON.stringify(estudante);
    </code></pre>

    <h3>String para Objeto</h3>
    <p><u>Função JSON.parse()</u></p>
    <pre><code>
    const objEstudante = JSON.parse(stringEstudante);
    </code></pre>


    
    
</body>
</html>